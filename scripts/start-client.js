// "use strict";

// // Do this as the first thing so that any code reading it knows the right env.
// process.env.BABEL_ENV = "development";
// process.env.NODE_ENV = "development";

// // Makes the script crash on unhandled rejections instead of silently
// // ignoring them. In the future, promise rejections that are not handled will
// // terminate the Node.js process with a non-zero exit code.
// process.on("unhandledRejection", err => {
//   throw err;
// });

// const fs = require("fs");
// const chalk = require("chalk");
// const webpack = require("webpack");
// const serve = require("webpack-serve");
// const clearConsole = require("react-dev-utils/clearConsole");
// const {
//   choosePort,
//   createCompiler,
//   prepareProxy,
//   prepareUrls
// } = require("react-dev-utils/WebpackDevServerUtils");
// const openBrowser = require("react-dev-utils/openBrowser");

// const paths = require("../config/paths");
// const config = require("../config/webpack.config.dev");
// const { getClientEnvironment } = require("../config/env");

// // const useYarn = fs.existsSync(paths.yarnLockFile);
// // const isInteractive = process.stdout.isTTY;

// // const env = getClientEnvironment(paths.publicUrl);

// // if (env.HOST) {
// //   console.log(
// //     chalk.cyan(
// //       `Attempting to bind to HOST environment variable: ${chalk.yellow(
// //         chalk.bold(env.HOST)
// //       )}`
// //     )
// //   );
// //   console.log(
// //     `If this was unintentional, check that you haven't mistakenly set it in your shell.`
// //   );
// //   console.log(`Learn more here: ${chalk.yellow("http://bit.ly/2mwWSwH")}`);
// //   console.log();
// // }

// const startDevServer = async () => {
//   // We attempt to use the default port but if it is busy, we offer the user to
//   // run on a different port. `choosePort()` Promise resolves to the next free port.
//   // const defaultPort = env.REACT_APP_PORT;
//   // const port = await choosePort(env.HOST, defaultPort);
//   // if (port === null) {
//   //   return Promise.reject("Unable to find a port");
//   // }

//   const devServer = serve({ config });
//   devServer.then(server => {
//     server.on("listening", (koa, opts) => {});
//   });
//   // const appName = require(paths.appPackageJson).name;
//   // const urls = prepareUrls(env.PROTOCOL, env.HOST, port);
//   // // Create a webpack compiler that is configured with custom messages.
//   // const compiler = createCompiler(webpack, config, appName, urls, useYarn);
//   // // Load proxy config
//   // const proxySetting = require(paths.appPackageJson).proxy;
//   // const proxyConfig = prepareProxy(proxySetting, paths.appPublic);
//   // // Serve webpack assets generated by the compiler over a web sever.
//   // const serverConfig = createDevServerConfig(proxyConfig, urls.lanUrlForConfig);
//   // const devServer = new WebpackDevServer(compiler, serverConfig);
//   // // Launch WebpackDevServer.
//   // devServer.listen(port, env.HOST, err => {
//   //   if (err) {
//   //     return console.log(err);
//   //   }
//   //   if (isInteractive) {
//   //     clearConsole();
//   //   }
//   //   console.log(chalk.cyan("Starting the development server...\n"));
//   //   openBrowser(urls.localUrlForBrowser);
//   // });

//   ["SIGINT", "SIGTERM"].forEach(sig => {
//     process.on(sig, async () => {
//       await devServer.then(server => close());
//       process.exit();
//     });
//   });
//   return devServer;
// };

// startDevServer().catch(err => {
//   if (err && err.message) {
//     console.log(err.message);
//   }
//   process.exit(1);
// });
